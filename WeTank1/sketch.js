// f it we tank
// no code in this project was generated by LLMs or AI


// TODO:
// cursor trail
// FONT 


// bottom scoreboard
// maybe a home screen i guess.
// make helper functions for font rendering for custom spacing? it might be expensive to render letter by letter
// modular level design system
// THEN move into core gameplay, moving, shooting, mining
// then i say improve the visual quality of the level and the gameplay elements

// global vars
let app;

let gameState;

let currMission = {
    number: 1,
    enemyTanks: 1
}

let scenes = {};
let frameCount = 0
let cframeRate = 0;
let avgTime = 0;
let lastTime = performance.now();
let cursorPoints = [];

let bgContainer;
let missionContainer;
let cursorSprite;
let fpsText;

let tankBGTexture;
let missionBannerTexture
let cursorTexture

async function init() {
    // i hope pixi is as easy as p5 lmao
    app = new PIXI.Application();
    await app.init({
        width: 854,
        height: 480,
        backgroundColor: 0xf0f000 // yellow, shouldnt be seen.
    })

    document.querySelector('main').appendChild(app.canvas);

    await loadAssets();

    gameState = "missionbrief"; // initial launch state, will be changed.

    setupMissionBrief(); // guess what this function does!

    app.ticker.add(gameLoop); // run the gameloop every frame
    app.ticker.maxFPS = 60;


    // global graphics (always there)

    // fps counter
    fpsText = new PIXI.Text({
        // text will be added in gameLoop
        style: {
        fontSize: 12,
        fill: 0x009900
        }
    });
    fpsText.x = 12;
    fpsText.y = 12;
    app.stage.addChild(fpsText);
    
    // hide cursor
    app.stage.cursor = 'none'

    // display cursor 
    const invertFilter = new PIXI.ColorMatrixFilter();
    invertFilter.matrix = [
        -1,  0,  0,  0,  1,  
        0, -1,  0,  0,  1, 
        0,  0, -1,  0,  1,  
        0,  0,  0,  1,  0   // unchanged alpha
    ]; // standard negating matrix

    const tempSprite = new PIXI.Sprite(cursorTexture);
    tempSprite.filters = [invertFilter];
    const invertedTexture = app.renderer.generateTexture(tempSprite);

    cursorSprite = new PIXI.Sprite(cursorTexture);
    cursorSprite.anchor.set(0.5);
    cursorSprite.scale.set(0.6)

    let cursorSpriteBlur = new PIXI.Sprite(cursorTexture);
    cursorSpriteBlur.anchor.set(0.5);
    cursorSpriteBlur.scale.set(0.6)

    cursorSpriteBlur.filters = [new PIXI.BlurFilter({
        strength: 0.25,
        quality: 4,
        kernelSize: 5,
    })]

    let cursorMask = new PIXI.Sprite(invertedTexture);
    cursorMask.filters = [invertFilter];
    cursorMask.anchor.set(0.5);
    cursorMask.scale.set(0.6)

    // now we want the BLACK in the sprite to MASK a MOVING gradient.
    const gradient = new PIXI.Graphics();
    gradient.rect(-cursorSprite.width/2,-cursorSprite.height,cursorSprite.width,cursorSprite.height*2);
    gradient.fill(new PIXI.FillGradient({
        type: 'linear',
        start: {x: 0, y: 0},
        end: {x: 0, y: 1},
        colorStops: [
            { offset: 0.0, color: 0x0000ff },
            { offset: 0.125, color: 0x00ffff },
            { offset: 0.25, color: 0x0000ff },
            { offset: 0.375, color: 0x00ffff },
            { offset: 0.5, color: 0x0000ff },
            { offset: 0.625, color: 0x00ffff },
            { offset: 0.75, color: 0x0000ff },
            { offset: 0.875, color: 0x00ffff },
            { offset: 1.0, color: 0x0000ff },
        ]
    })) // updated in gameLoop
    const gradientTexture = app.renderer.generateTexture(gradient);
    const gradientSprite = new PIXI.Sprite(gradientTexture);
    gradientSprite.anchor.set(0.5)

    gradientSprite.setMask({mask: cursorMask})

    app.stage.addChild(cursorMask); // the gradient
    app.stage.addChild(cursorSprite);
    app.stage.addChild(cursorSpriteBlur); // might be COMPLETELY uneccesary.
    app.stage.addChild(gradientSprite);


    
    app.stage.cursorMask = cursorMask; // can access these references later.
    app.stage.gradientSprite = gradientSprite;
    


    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointermove', (e) => {
        const {x,y} = e.global;
        cursorSprite.position.set(x, y);
        cursorMask.position.set(x, y);
        gradientSprite.position.set(x, y);
        cursorSpriteBlur.position.set(x, y);

    })

    // make cursor tail
    const tailWidth = 256; //2
    const tailHeight = 8; //8
    const tailGraphic = new PIXI.Graphics();
    // adds taper
    tailGraphic.moveTo(tailWidth, tailHeight / 2);//tailHeight/tailWidth, tailHeight/tailWidth
    tailGraphic.lineTo(0, tailHeight);
    tailGraphic.lineTo(0, 0);
    tailGraphic.closePath();
    tailGraphic.fill(new PIXI.FillGradient({
        type: 'linear',
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0 },
        colorStops: [
            { offset: 0.0, color: 0xddf2ff, alpha: 1 },// 1/6th of the way between white and cyan
            { offset: 1.0, color: 0x34c2ec, alpha: 0 } // 1/6th of the way between cyan and black
        ]
    }));
    
    const tailTexture = app.renderer.generateTexture(tailGraphic);
    const historySize = 12;
    cursorPoints = []
    for (let i = 0; i < historySize; i++){
        cursorPoints.push(new PIXI.Point(0+i*0.1,0+i*0.1));
    }
    const rope = new PIXI.MeshRope({texture: tailTexture, points: cursorPoints});
    //rope.blendMode = "add";

    app.stage.addChild(rope);

}

async function loadAssets(){ // akin to preload() in p5
    tankBGTexture = await PIXI.Assets.load('assets/images/tank_background_billboard_white.png')
    missionBannerTexture = await PIXI.Assets.load('assets/images/mission_info.png')
    cursorTexture = await PIXI.Assets.load('assets/images/cursor_1.png')

    const font = new FontFace( // YOURE a font face
        'weFont',
        'url(assets/en_US.ttf)'
    );
    await font.load();
    document.fonts.add(font);

}

function setupMissionBrief() { // combine the tank bg and mission brief into one container.
    // only separete containers if you need diff update logic, diff z ordering, or if parts are reused.
    scenes.missionbrief = new PIXI.Container();
    app.stage.addChild(scenes.missionbrief);
    // create a conrtrainer for the tank bg, and the mission banner
    bgContainer = new PIXI.Container();
    const tilesX = Math.floor(app.screen.width / 64) + 2;
    const tilesY = Math.floor(app.screen.height / 64) + 2;
    // 64x64 is the size of the tank background tile piece.
    // +2 is to allow "infinite" scrolling.

    for (let i = 0; i < tilesX; i++) {
        for (let j = 0; j < tilesY; j++) {
            const tile = new PIXI.Sprite(tankBGTexture);
            tile.tint = 0xE7E6B3; // the sprites are greyscale.
            tile.x = i * 64;
            tile.y = j*64;
            bgContainer.addChild(tile);
    }
}
    //done with scrolliong tank background
    scenes.missionbrief.addChild(bgContainer);
    
    // now construct the mission banner on top
    // this will evenatully need to be variable, for different mission levels

    for (let i = 0; i < 5; i++){
        const banner = new PIXI.Sprite(missionBannerTexture)
        banner.tint = 0xC04736;
        banner.y = (app.screen.height / 5) + i * app.screen.height/11; // i think its 47 cuz thats half of 96, its height. i lowk nudged it until it looped perfectly.
        banner.width = app.screen.width;
        banner.height = app.screen.width/14; // this kept it square.
        scenes.missionbrief.addChild(banner);
    }
    // banner texture, do text.
    const titleShadow = new PIXI.Text({
        text: `Mission ${currMission.number}`,
        style: {
            fontFamily: 'weFont',
            fontSize: (52/854)*app.screen.width, 
            fill: 0x973627,
            letterSpacing: (10/854)*app.screen.width,
        }
    })
    titleShadow.anchor.set(0.5) // position by center 
    titleShadow.x = app.screen.width / 2 + (app.screen.height / 60);
    titleShadow.y = app.screen.height / 5 + (app.screen.height / 8) + app.screen.height / 60;
    // trying to avoid hardcoded values in case i want variable screen size.
    scenes.missionbrief.addChild(titleShadow);

    const title = new PIXI.Text({
        text: `Mission ${currMission.number}`,
        style: {
            fontFamily: 'weFont',
            fontSize: (52/854)*app.screen.width, 
            fill: 0xFAE59F,
            stroke: {color: 0x634921, width : (8/854)*app.screen.width},
            letterSpacing: (10/854)*app.screen.width,
            //LineJoin: 'round', miterLevel: 5, // NEVER WORKED???
        }
    })
    title.anchor.set(0.5);
    title.x = app.screen.width / 2;
    title.y = app.screen.height / 5 + app.screen.height / 8;
    scenes.missionbrief.addChild(title);

    const enemyText = new PIXI.Text({
        text: `Enemy Tanks: ${currMission.enemyTanks}`,
        style: {
            fontFamily: 'weFont',
            fontSize: (32/854)*app.screen.width, 
            fill: 0xFAE59F,
            stroke: {color: 0x634921, width : (8/854)*app.screen.width},
            letterSpacing: (6.15/854)*app.screen.width,
        }
    });
    enemyText.anchor.set(0.5);
    enemyText.x = app.screen.width / 2;
    enemyText.y = (app.screen.height / 5) + (app.screen.height / 3);
    scenes.missionbrief.addChild(enemyText);  // so much for some lines of text damn

    // gold bars 
    const topBar = new PIXI.Graphics();
    topBar.rect(0, (app.screen.height / 5)  // where banner element starts
    + app.screen.height / 60, // plus the gap
     app.screen.width, app.screen.height / 40);
    topBar.fill(0xCCA82A);
    scenes.missionbrief.addChild(topBar);
    
    const bottomBar = new PIXI.Graphics();
    bottomBar.rect(0, 
        (app.screen.width/14 * 5) // height of the banner element
        - app.screen.height / 60 // minus the gap
        + app.screen.height / 40, // minus the width of the bar
         app.screen.width, app.screen.height / 40);
    bottomBar.fill(0xCCA82A);
    scenes.missionbrief.addChild(bottomBar);
}

function gameLoop(ticker) {
    frameCount++;

    // background scroll ( IF GAME STATE MISSION BRIEF )
    bgContainer.x = (frameCount/2)%64 - 64
    bgContainer.y = -(frameCount/2)%64

    if (app.stage.gradientSprite) {
        const gradientSprite = app.stage.gradientSprite;
        const progress = (frameCount/2%100)/100 // progress = 0-99%
        gradientSprite.y = cursorSprite.y-cursorSprite.height/2 + progress*cursorSprite.width;
    }

    //update fps counter
    const currentTime = performance.now();
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    if (frameCount % 10 == 0) {
        cframeRate = Math.floor(10/avgTime * 1000);
        avgTime = 0
        fpsText.text = cframeRate.toString();
    } else {
        avgTime += deltaTime
    }

    if (frameCount % 2 == 0) { // add that chunkiness.
        cursorPoints.pop();
        cursorPoints.unshift(new PIXI.Point(cursorSprite.x, cursorSprite.y));

    }

    // idk. game logic stuff.
}

init();

