// f it we tank
// no code in this project was generated by LLMs or AI


// TODO:
// diamond board NEEDS to be less dark.
// trail needs to be more transparent, have slight borders 
// bottom scoreboard ( tank icon, mii, x, lives)


// maybe a home screen i guess.
// modular level design system
// THEN move into core gameplay, moving, shooting, mining
// then i say improve the visual quality of the level and the gameplay elements
// its taking 300ms to load the first graphic currently. for reference most frames are about 3ms if unclamped.



// global vars

let app;

let gameState = {
    name: "",
    frames: "",
    // any other info we wanna spread between the gameStates I suppose.
};

let currMission = {
    number: 1,
    enemyTanks: 1
}

let scenes = {};
let sounds = {};
let frameCount = 0
let cframeRate = 0;
let avgTime = 0;
let lastTime = performance.now();
let load = true;
let cursorPoints = [];

let bgContainer;
let missionContainer;
let cursorSprite;
let fpsText;

let tankBGTexture;
let missionBannerTexture
let cursorTexture



async function init() {
    // i hope pixi is as easy as p5 lmao
    app = new PIXI.Application();
    await app.init({
        width: 854,
        height: 480,
        backgroundColor: '#8A8A8A' // yellow, shouldnt be seen.
    })

    document.querySelector('main').appendChild(app.canvas);

    await loadAssets();

    gameState.name = "missionbrief"; // initial launch state, will be changed.

    setupMissionBrief(); // guess what this function does!

    app.ticker.add(gameLoop); // run the gameloop every frame
    app.ticker.maxFPS = 60;


    // global graphics (always there)

    // fps counter
    fpsText = new PIXI.Text({
        // text will be added in gameLoop
        style: {
        fontSize: 12,
        fill: 0x009900
        }
    });
    fpsText.x = 12;
    fpsText.y = 12;
    app.stage.addChild(fpsText);
    
    // hide cursor
    app.stage.cursor = 'none'

    // display cursor 
    const invertFilter = new PIXI.ColorMatrixFilter();
    invertFilter.matrix = [
        -1,  0,  0,  0,  1,  
        0, -1,  0,  0,  1, 
        0,  0, -1,  0,  1,  
        0,  0,  0,  1,  0   // unchanged alpha
    ]; // standard negating matrix

    const cursorContainer = new PIXI.Container();
    const tempSprite = new PIXI.Sprite(cursorTexture);
    tempSprite.filters = [invertFilter];
    const invertedTexture = app.renderer.generateTexture(tempSprite);

    cursorSprite = new PIXI.Sprite(cursorTexture);
    cursorSprite.anchor.set(0.5);
    cursorSprite.scale.set(0.6)

    let cursorSpriteBlur = new PIXI.Sprite(cursorTexture);
    cursorSpriteBlur.anchor.set(0.5);
    cursorSpriteBlur.scale.set(0.6)

    cursorSpriteBlur.filters = [new PIXI.BlurFilter({
        strength: 0.25,
        quality: 4,
        kernelSize: 5,
    })]

    let cursorMask = new PIXI.Sprite(invertedTexture);
    cursorMask.filters = [invertFilter];
    cursorMask.anchor.set(0.5);
    cursorMask.scale.set(0.6)

    // now we want the BLACK in the sprite to MASK a MOVING gradient.
    const gradient = new PIXI.Graphics();
    gradient.rect(-cursorSprite.width/2,-cursorSprite.height,cursorSprite.width,cursorSprite.height*2);
    gradient.fill(new PIXI.FillGradient({
        type: 'linear',
        start: {x: 0, y: 0},
        end: {x: 0, y: 1},
        colorStops: [
            { offset: 0.0, color: 0x0000ff },
            { offset: 0.125, color: 0x00ffff },
            { offset: 0.25, color: 0x0000ff },
            { offset: 0.375, color: 0x00ffff },
            { offset: 0.5, color: 0x0000ff },
            { offset: 0.625, color: 0x00ffff },
            { offset: 0.75, color: 0x0000ff },
            { offset: 0.875, color: 0x00ffff },
            { offset: 1.0, color: 0x0000ff },
        ]
    })) // updated in gameLoop
    const gradientTexture = app.renderer.generateTexture(gradient);
    const gradientSprite = new PIXI.Sprite(gradientTexture);
    gradientSprite.anchor.set(0.5)

    gradientSprite.setMask({mask: cursorMask})

    cursorContainer.addChild(cursorMask)
    cursorContainer.addChild(cursorSprite)
    cursorContainer.addChild(cursorSpriteBlur) // might not do anything. lol.
    cursorContainer.addChild(gradientSprite)
    app.stage.addChild(cursorContainer)
    app.stage.cursorContainer = cursorContainer // allow future access    


    app.stage.eventMode = 'static';
    app.stage.hitArea = app.screen;
    app.stage.on('pointermove', (e) => {
        const {x,y} = e.global;
        cursorContainer.position.set(x, y);
    })

    // make cursor tail / trail

    const tailWidth = 256; //256
    const tailHeight = 8; //8
    const tailGraphic = new PIXI.Graphics();
    const tailGraphic2 = new PIXI.Graphics(); // cant have 2 gradients on one obj, so i used two. lol.
    const tailContainer = new PIXI.Container();
    // adds taper
    tailGraphic.moveTo(tailWidth, tailHeight / 2);//tailHeight/tailWidth, tailHeight/tailWidth
    tailGraphic.lineTo(0, tailHeight);
    tailGraphic.lineTo(0, 0);
    tailGraphic.closePath();
    tailGraphic.fill(new PIXI.FillGradient({
        type: 'linear',
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0 },
        colorStops: [
            { offset: 0.0, color: '#f2faffb4' },// 1/6th of the way between white and cyan
            { offset: 0.3, color: '#00c3ff88' }, // 1/6th of the way between cyan and black
            { offset: 1.0, color: '#0099c800' },
        ]
    }));

    tailGraphic2.moveTo(tailWidth, tailHeight / 2);//tailHeight/tailWidth, tailHeight/tailWidth
    tailGraphic2.lineTo(0, tailHeight);
    tailGraphic2.lineTo(0, 0);
    tailGraphic2.closePath();
    tailGraphic2.fill(new PIXI.FillGradient({
        type: 'linear',
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        colorStops: [
            { offset: 0.0, color: '#0008' },
            { offset: 0.3, color: '#fff0' },
            { offset: 0.7, color: '#fff0' }, // ok so technically this doesn't work
            { offset: 1.0, color: '#0008' } 
        ]
    }));
    // note for future self. the second gradient is a vertical linear gradient.
    // it is a square. So when it is applied on the trail, an isoceles triangle,
    // the tail of the triangle does NOT get the gradient, it just gets the middle.
    
    tailGraphic2.blendMode = 'normal';
    // should i be destroying the gradients after use?
    
    // tailGraphic.x=30
    // tailGraphic2.x=30
    // tailGraphic.y=30                 // debug trail
    // tailGraphic2.y=30
    // app.stage.addChild(tailGraphic)
    // app.stage.addChild(tailGraphic2)
    
    tailContainer.addChild(tailGraphic);
    tailContainer.addChild(tailGraphic2);
    const finalTailTexture = app.renderer.generateTexture(tailContainer);
    const historySize = 12;
    cursorPoints = []
    for (let i = 0; i < historySize; i++){
        cursorPoints.push(new PIXI.Point(0+i*0.1,0+i*0.1));
    }
    const cursorTrail = new PIXI.MeshRope({texture: finalTailTexture, points: cursorPoints});
    
    //cursorTrail.blendMode = "screen";

    app.stage.addChild(cursorTrail);
    app.stage.cursorTrail = cursorTrail;

}

async function loadAssets(){ // akin to preload() in p5
    tankBGTexture = await PIXI.Assets.load('assets/images/missionbrief/tank_background_billboard_white.png')
    missionBannerTexture = await PIXI.Assets.load('assets/images/missionbrief/mission_info.png')
    cursorTexture = await PIXI.Assets.load('assets/images/missionbrief/cursor_1.png')

    const font = new FontFace( // YOURE a font face
        'weFont',
        'url(assets/en_US.ttf)'
    );
    await font.load();
    document.fonts.add(font);

}

function gameLoop(ticker) {
    frameCount++;
    gameState.frames++;

    if (load == true){
        console.log(`${performance.now() - lastTime} milliseconds to load`)
        load = false;
    }

    // THINGS THAT ALWAYS PERSIST

    //update fps counter
    const currentTime = performance.now();
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    if (frameCount % 10 == 0) {
        cframeRate = Math.floor(10/avgTime * 1000);
        avgTime = 0
        fpsText.text = cframeRate.toString();
    } else {
        avgTime += deltaTime
    }

    //update cursor trail
    if (frameCount % 2 == 0) { // add that chunkiness.
        cursorPoints.pop();
        cursorPoints.unshift(new PIXI.Point(app.stage.cursorContainer.x, app.stage.cursorContainer.y));

    }

    switch (gameState.name) {
        case "missionbrief":
                if (gameState.frames == 1 ){ // things to do once.
                    sounds.missionbrief.play();
                    setupLevel(); // async func
                }


                // background scroll ( IF GAME STATE MISSION BRIEF )
                bgContainer.x = (frameCount/2)%64 - 64
                bgContainer.y = -(frameCount/2)%64

                if (app.stage.gradientSprite) {
                    const gradientSprite = app.stage.gradientSprite;
                    const progress = (frameCount/2%100)/100 // progress = 0-99%
                    gradientSprite.y = cursorSprite.y-cursorSprite.height/2 + progress*cursorSprite.width;
                }

                // zoom in the text.
                // as of rn, the titles are 6 and 7 and
                // the enemy text is 8 and 9 
                if (scenes.missionbrief.children[6].scale.x < 1){
                    // 0.1 * 1.1^25 frames = 1.01
                    const frames = 12
                    const scalar = (1/0.1)**(1/frames)
                    scenes.missionbrief.children[6].scale.x *= scalar
                    scenes.missionbrief.children[7].scale.x *= scalar
                    scenes.missionbrief.children[8].scale.x *= scalar
                    scenes.missionbrief.children[9].scale.x *= scalar
                    scenes.missionbrief.children[6].scale.y *= scalar
                    scenes.missionbrief.children[7].scale.y *= scalar
                    scenes.missionbrief.children[8].scale.y *= scalar
                    scenes.missionbrief.children[9].scale.y *= scalar 
                } if (scenes.missionbrief.children[6].scale.x > 1){
                    scenes.missionbrief.children[6].scale.x = 1
                    scenes.missionbrief.children[7].scale.x = 1
                    scenes.missionbrief.children[8].scale.x = 1
                    scenes.missionbrief.children[9].scale.x = 1
                    scenes.missionbrief.children[6].scale.y = 1
                    scenes.missionbrief.children[7].scale.y = 1
                    scenes.missionbrief.children[8].scale.y = 1
                    scenes.missionbrief.children[9].scale.y = 1 
                }

            

                // once the mission brief screen has been displayed for 3 seconds, fade out and go to game.
                if(gameState.frames > 60*3) {
                    gameState.name = 'pregame';
                    gameState.frames = 0;
                    // TODO transition?
                    scenes.missionbrief.destroy()
                }
                break; // since it breaks, it will fully loop
        case "pregame":
                if (gameState.frames == 1) {
                    const id = sounds.intro.play();
                    sounds.intro.once('end', (soundId) => {
                        if (soundId == id) {
                            gameState.name = 'level';
                            gameState.frames = 0;
                        }
                    })
                }
                
                break;
        case 'level':
            if (gameState.frames == 10) { // the sound is a little delayed
                    gameState.soundId = sounds.brown.play();
                    // loops
                }
            break;
        case 'endlevel':
            if (gameState.frames == 1) {
                sounds.brown.stop()
            }
            break;
            }
}

init();

